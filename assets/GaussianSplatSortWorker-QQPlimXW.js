class M{constructor(e,s,c,u=!1){this.distances=e,this.sortOrderIndices=s,this.numGaussians=c,this.preciseSort=u}}class d{constructor(e,s){this.distances=e,this.sortedOrderIndices=s}}let i=null,o=null;const m=10,p=20,y=.25;function g(r,e){(i==null?void 0:i.length)!==r&&(i=new Uint32Array(r)),o&&o.length===1+(1<<e)?o.fill(0):o=new Uint32Array(1+(1<<e))}function b(r,e){const s=r.length,c=Math.max(m,Math.min(p,Math.round(Math.log2(s/y)))),u=1+(1<<c);g(s,c);let a=r[0],l=r[0];for(let t=0;t<r.length;t++)a=Math.min(a,r[t]),l=Math.max(l,r[t]);const f=l-a;if(f<1e-6)for(let t=0;t<s;++t)i[t]=0,o[0]++;else{const t=(1<<c)/f;for(let n=0;n<s;n++){const h=(r[n]-a)*t>>>0;i[n]=h,o[h]++}}for(let t=1;t<u;t++)o[t]+=o[t-1];for(let t=0;t<s;t++){const n=i[t];e[--o[n]]=t}}async function S(r){const{distances:e,sortOrderIndices:s,preciseSort:c,numGaussians:u}=r,a=e.subarray(0,u),l=s.subarray(0,u);if(a.length===0||l.length===0)return{result:new d(e,s),transferList:[e.buffer,s.buffer]};if(c){const f=Array.from(l.keys());f.sort((n,h)=>a[n]-a[h]||n-h);const t=f.map(n=>l[n]);l.set(t)}else b(a,l);return{result:new d(e,s),transferList:[e.buffer,s.buffer]}}function w(){i=null,o=null}export{M as SplatSortWorkerInput,d as SplatSortWorkerOutput,w as destroy,S as sort};
