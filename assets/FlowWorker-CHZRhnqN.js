import{gs as S,jI as _,jJ as v,jK as j,z,U as E}from"./index-CegpXLBL.js";import{f as y,d as $}from"./dataUtils-C9Kc2aIa.js";function T(n,a,t){const{extent:s,valid:u}=n,[e,l,r,i]=s;return!(t<l||t>i)&&(u!=null&&e>r?a>=r||a<=e:a>=e&&a<=r)}function b(n,a,t,s){const{extent:u,modelSize:e,valid:l}=n,[r,i,c]=u,f=k(r,c,l);let o=a/e[0]*f+r;return l!=null&&s&&(o=new S(l[0],l[1]).normalize(o)),[o,(e[1]-t)/e[1]*_(u)+i]}function k(n,a,t){if(t!=null&&n>a){const[s,u]=t;return u-n+(a-s)}return a-n}function I(n){return n?4:3}function A(n,a,t){const[s,u]=t.modelSize;let e=null;const l=new Map;a.forEach(i=>{l.set(i.lij,y(n,i))});const r=(i,c,f)=>v(i.extent,c,f);return(i,c)=>{const f=Math.round(i),o=Math.round(c);if(!n.wrapAround&&(f<0||f>=s||o<0||o>=u))return[0,0];const[d,h]=b(t,i,c,!0);if(!T(t,d,h))return[0,0];if(e==null||!r(e,d,h)){e=null;for(const[F,x]of a)if(r(x,d,h)){e=x;break}}if((e==null?void 0:e.data)==null)return[0,0];const g=l.get(e.lij);if(g==null)return[0,0];const{width:M,height:w,extent:p}=e;return g((d-p[0])/j(p)*M,w-(h-p[1])/_(p)*w)}}let m=class{constructor(){this._tileData=new Map}async generateStreamlines(n){const{flowData:a,flowExtentInfo:t,needsMagnitude:s,simulationSettings:u,startPositions:e}=n,l=D(y(u,a),u,t.modelSize,s,e);return{result:{streamlines:l},transferList:l==null?void 0:l.map(r=>r.vertices.buffer)}}async generateTiledStreamlines(n){const{flowDataTiles:a,flowExtentInfo:t,needsMagnitude:s,reset:u,simulationSettings:e,startPositions:l}=n;this._updateTileData(a,u);const r=D(A(e,this._tileData,t),e,t.modelSize,s,l);return{result:{streamlines:r},transferList:(r==null?void 0:r.map(i=>i.vertices.buffer))??[]}}_updateTileData(n,a){a&&this._tileData.forEach((t,s)=>{n.get(s)==null&&this._tileData.delete(s)}),n.forEach((t,s)=>{t.type==="delete"?this._tileData.delete(s):t.type!=="on-worker"&&t.type!=="waiting"&&this._tileData.set(s,t.data)})}};m=z([E("esri.views.3d.support.flow.FlowWorker")],m);const J=m;function D(n,a,t,s,u){if(n==null)return;const e=$(a,n,t[0],t[1],{positions:u}),l=[],r=I(s);for(const{vertices:i,stage:c}of e){const f=new Float32Array(i.length*r);for(let o=0;o<i.length;o++)f[o*r]=i[o].x,f[o*r+1]=i[o].y,f[o*r+2]=i[o].t,s&&(f[o*r+3]=i[o].speed);l.push({vertices:f,stage:c,hasMagnitude:s})}return l}export{J as default};
