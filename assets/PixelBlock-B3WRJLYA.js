import{z as P,b as L,g as F,m as M,D as m,F as A,fK as G,Z as R}from"./index-DalZQxea.js";let N=class{constructor(e=null,i=null,a=null){this.minValue=e,this.maxValue=i,this.noDataValue=a}};const I=9999999e31,j=2e-7,_={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767],u32:[0,4294967295],s32:[-2147483648,2147483647],f32:[-34028234663852886e22,34028234663852886e22],f64:[-Number.MAX_VALUE,Number.MAX_VALUE],unknown:void 0,c64:void 0,c128:void 0};function C(t){return _[t]??[-34028234663852886e22,34028234663852886e22]}const E={u1:1,u2:1,u4:1,u8:1,s8:1,u16:2,s16:2,u32:4,s32:4,f32:4,f64:8,unknown:4,c64:16,c128:32};function $(t){return E[t]}function J(t){return $(t.pixelType)*t.bandCount}function K(t,e){return t==null||e==null?"s32":t<0?t>=-128&&e<128?"s8":t>=-32768&&e<32768?"s16":"s32":e<256?"u8":e<65536?"u16":"u32"}function D(t){return((t==null?void 0:t.startsWith("s"))||(t==null?void 0:t.startsWith("u")))??!1}function Z(t,e,i,a){let[n,l]=C(i);const s=D(i);return s&&(n-=1e-5,l+=1e-5),s?i.startsWith("u")?S(t,e,a,[n,l]):O(t,e,a,[n,l]):X(t,e,a,[n,l])}function H(t,e){for(let i=0;i<e.length;i++)e[i]&&isNaN(t[i])&&(e[i]=0,t[i]=0)}function S(t,e,i,a){const[n,l]=a;for(let s=0;s<e.length;s++)if(e[s]){const o=t[s];o<n||o>l?e[s]=0:i[s]=o+.5|0}}function O(t,e,i,a){const[n,l]=a;for(let s=0;s<e.length;s++)if(e[s]){const o=t[s];o<n||o>l?e[s]=0:i[s]=o+(o>0?.5:-.5)|0}}function X(t,e,i,a){const[n,l]=a;for(let s=0;s<e.length;s++)if(e[s]){const o=t[s];o<n||o>l?e[s]=0:i[s]=o}}function Q(t,e,i){var u,k;if(t.depthCount&&t.depthCount>1)return;const{pixels:a,statistics:n,pixelType:l}=t,s=a[0].length,o=t.bandMasks??[],r=t.mask??new Uint8Array(s).fill(255),g=l==="f32"||l==="f64",f=C(l);let c=!1;for(let h=0;h<a.length;h++){const x=typeof e=="number"?e:e[h];if(x==null)continue;const U=((u=n==null?void 0:n[h])==null?void 0:u.minValue)??f[0],T=((k=n==null?void 0:n[h])==null?void 0:k.maxValue)??f[1];if(U>x+Number.EPSILON||T<x-Number.EPSILON)continue;const v=o[h]||r.slice(),y=a[h],V=i==null?void 0:i.customFloatTolerance;if(g&&V!==0){let b=V;b||(b=Math.abs(x)>=I?j*Math.abs(x):l==="f32"?2**-23:Number.EPSILON);for(let B=0;B<y.length;B++)v[B]&&Math.abs(y[B]-x)<b&&(y[B]=0,v[B]=0,r[B]=0,c=!0)}else for(let b=0;b<y.length;b++)v[b]&&y[b]===x&&(y[b]=0,v[b]=0,r[b]=0,c=!0);o[h]=v}if(c){const h=t.bandMasks||t.pixels.length>1?o:null;i!=null&&i.matchAllNoData?t.mask=h&&h.length>1?p(h):r:(t.bandMasks=h,t.mask=r)}function p(h){if(h.length<2)return h[0];const x=h[0].length,U=new Uint8Array(x).fill(0);for(let T=0;T<h.length;T++){const v=h[T];for(let y=0;y<x;y++)v[y]&&(U[y]=255)}return U}c&&"updateStatistics"in t&&t.updateStatistics()}var w;let d=w=class extends P{static createEmptyBand(t,e){return new(w.getPixelArrayConstructor(t))(e)}static combineBandMasks(t){if(t.length<2)return t[0];const e=t[0].length,i=new Uint8Array(e).fill(255);for(let a=0;a<t.length;a++){const n=t[a];for(let l=0;l<e;l++)n[l]||(i[l]=0)}return i}static getPixelArrayConstructor(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array}return e}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let e=t.toLowerCase();return["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e}getPlaneCount(){var t;return(t=this.pixels)==null?void 0:t.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new L("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new N)}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(i=>W(i,this.mask));const t=this.mask;let e=0;if(t!=null)for(let i=0;i<t.length;i++)t[i]&&e++;else e=this.width*this.height;this.validPixelCount=e}clamp(t){if(!t||t==="f64"||t==="f32"||!this.pixels)return;const[e,i]=C(t),a=this.pixels,n=this.width*this.height,l=a.length;let s,o,r;const g=[];for(let f=0;f<l;f++){r=w.createEmptyBand(t,n),s=a[f];for(let c=0;c<n;c++)o=s[c],r[c]=o>i?i:o<e?e:o;g.push(r)}this.pixels=g,this.pixelType=t}extractBands(t){var c;const{pixels:e,statistics:i}=this;if(t==null||t.length===0||!e||e.length===0)return this;const a=e.length,n=t.some(p=>p>=e.length),l=a===t.length&&!t.some((p,u)=>p!==u);if(n||l)return this;const s=((c=this.bandMasks)==null?void 0:c.length)===a?t.map(p=>this.bandMasks[p]):void 0;let{mask:o,validPixelCount:r}=this;const{width:g,height:f}=this;return s!=null&&s.length&&(o=w.combineBandMasks(s),r=o.filter(p=>!!p).length),new w({pixelType:this.pixelType,width:g,height:f,mask:o,bandMasks:s,validPixelCount:r,maskIsAlpha:this.maskIsAlpha,pixels:t.map(p=>e[p]),statistics:i&&t.map(p=>i[p])})}clone(){const t=new w({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount,premultiplyAlpha:this.premultiplyAlpha,depthCount:this.depthCount});let e;this.mask!=null&&(t.mask=new Uint8Array(this.mask)),this.noDataValues&&(t.noDataValues=[...this.noDataValues]),this.bandMasks&&(t.bandMasks=this.bandMasks.map(a=>new Uint8Array(a)));const i=w.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const a=!!this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=a?this.pixels[e].slice():new i(this.pixels[e])}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=F(this.statistics[e]);return t}getTransferableObject(){const{pixels:t,bandMasks:e,mask:i}=this;this.pixels=[],this.bandMasks=void 0,this.mask=void 0;const a=this.toJSON();this.pixels=t,this.bandMasks=e,this.mask=i,a.pixels=t&&[...t],a.bandMasks=e&&[...e],a.mask=i;const n=[];return[...t??[],i,...e??[]].filter(l=>l!=null&&ArrayBuffer.isView(l)).forEach(l=>{l&&!n.includes(l.buffer)&&n.push(l.buffer)}),{pixelBlock:a,transferList:n}}_fillFrom8Bit(t){const{mask:e,maskIsAlpha:i,premultiplyAlpha:a,pixels:n}=this;if(!t||!(n!=null&&n.length))return void M.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let l,s,o,r;l=s=o=n[0],n.length>=3?(s=n[1],o=n[2]):n.length===2&&(s=n[1]);const g=new Uint32Array(t),f=this.width*this.height;if(l.length===f)if(e!=null&&e.length===f)if(i)for(r=0;r<f;r++){const c=e[r];if(c){const p=c/255;g[r]=a?c<<24|o[r]*p<<16|s[r]*p<<8|l[r]*p:c<<24|o[r]<<16|s[r]<<8|l[r]}}else for(r=0;r<f;r++)e[r]&&(g[r]=255<<24|o[r]<<16|s[r]<<8|l[r]);else for(r=0;r<f;r++)g[r]=255<<24|o[r]<<16|s[r]<<8|l[r];else M.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:e,mask:i,statistics:a}=this;if(!t||!(e!=null&&e.length))return void M.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const n=this.pixelType;let l=1,s=0,o=1;if(a&&a.length>0){for(const h of a)if(h.minValue!=null&&(s=Math.min(s,h.minValue)),h.maxValue!=null&&h.minValue!=null){const x=h.maxValue-h.minValue;o=Math.max(o,x)}l=255/o}else{let h=255;n==="s8"?(s=-128,h=127):n==="u16"?h=65535:n==="s16"?(s=-32768,h=32767):n==="u32"?h=4294967295:n==="s32"?(s=-2147483648,h=2147483647):n==="f32"?(s=-34e38,h=34e38):n==="f64"&&(s=-Number.MAX_VALUE,h=Number.MAX_VALUE),l=255/(h-s)}const r=new Uint32Array(t),g=this.width*this.height;let f,c,p,u,k;if(f=c=p=e[0],f.length!==g)return M.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(c=e[1],e.length>=3&&(p=e[2]),i!=null&&i.length===g)for(u=0;u<g;u++)i[u]&&(r[u]=255<<24|(p[u]-s)*l<<16|(c[u]-s)*l<<8|(f[u]-s)*l);else for(u=0;u<g;u++)r[u]=255<<24|(p[u]-s)*l<<16|(c[u]-s)*l<<8|(f[u]-s)*l;else if(i!=null&&i.length===g)for(u=0;u<g;u++)k=(f[u]-s)*l,i[u]&&(r[u]=255<<24|k<<16|k<<8|k);else for(u=0;u<g;u++)k=(f[u]-s)*l,r[u]=255<<24|k<<16|k<<8|k}_fillFrom32Bit(t){const{pixels:e,mask:i}=this;if(!t||!(e!=null&&e.length))return M.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let a,n,l,s;a=n=l=e[0],e.length>=3?(n=e[1],l=e[2]):e.length===2&&(n=e[1]);const o=this.width*this.height;if(a.length!==o)return M.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let r=0;if(i!=null&&i.length===o)for(s=0;s<o;s++)t[r++]=a[s],t[r++]=n[s],t[r++]=l[s],t[r++]=1&i[s];else for(s=0;s<o;s++)t[r++]=a[s],t[r++]=n[s],t[r++]=l[s],t[r++]=1}};function W(t,e){let i=1/0,a=-1/0;const n=t.length;let l,s=0;if(e!=null)for(l=0;l<n;l++)e[l]&&(s=t[l],i=s<i?s:i,a=s>a?s:a);else for(l=0;l<n;l++)s=t[l],i=s<i?s:i,a=s>a?s:a;return new N(i,a)}m([A({json:{write:!0}})],d.prototype,"width",void 0),m([A({json:{write:!0}})],d.prototype,"height",void 0),m([A({json:{write:!0}})],d.prototype,"pixelType",void 0),m([G("pixelType")],d.prototype,"castPixelType",null),m([A({json:{write:!0}})],d.prototype,"validPixelCount",void 0),m([A({json:{write:!0}})],d.prototype,"mask",void 0),m([A({json:{write:!0}})],d.prototype,"maskIsAlpha",void 0),m([A({json:{write:!0}})],d.prototype,"pixels",void 0),m([A()],d.prototype,"premultiplyAlpha",void 0),m([A({json:{write:!0}})],d.prototype,"statistics",void 0),m([A({json:{write:!0}})],d.prototype,"depthCount",void 0),m([A({json:{write:!0}})],d.prototype,"noDataValues",void 0),m([A({json:{write:!0}})],d.prototype,"bandMasks",void 0),d=w=m([R("esri.layers.support.PixelBlock")],d);export{Z as a,J as b,d as c,H as f,Q as g,K as i,N as l,D as r,C as u};
