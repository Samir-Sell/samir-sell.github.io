import{O as _,cG as C,ds as v,ck as y,dt as b,aS as I,du as p,dv as w}from"./index-7LVg-iY6.js";function M(i,o,e){var s;const a=((s=e==null?void 0:e.createCollection)==null?void 0:s.call(e))??new _,r=e!=null&&e.recycleItems?new R:null,l=(t,n=0)=>{if(!(t!=null&&t.length))return;const d=a.splice(n,t.length);r?r.processRemoved(t):d.forEach(m)},u=(t,n=0)=>{if(!(t!=null&&t.length))return;const d=[];for(const c of t){const g=r==null?void 0:r.use(c);if(g)d.push(g);else{const h=o(c);r==null||r.register(c,h),d.push(h)}}a.addMany(d,n)},f=C(i,"after-splice",({added:t,start:n,removed:d})=>{l(d,n),u(t,n)},{sync:!0,onListenerRemove:t=>l(t.items),onListenerAdd:t=>u(t.items)});return a.addHandles(f),a}class R{constructor(){this._originalToMapped=new Map,this._removedItemCandidates=new Set,this._garbageCollectionQueued=!1}processRemoved(o){var a;if(!(o!=null&&o.length))return;const{_removedItemCandidates:e}=this;for(const r of o)(a=this._getItem(r))!=null&&a.markRemoved()&&(e.add(r),this._queueGarbageCollection())}use(o){const e=this._getItem(o);return e&&(e.removed=!1),e==null?void 0:e.item}register(o,e){this._originalToMapped.set(o,new $(e))}_getItem(o){return this._originalToMapped.get(o)}_queueGarbageCollection(){this._garbageCollectionQueued||(this._garbageCollectionQueued=!0,queueMicrotask(()=>this._garbageCollectCandidates()))}_garbageCollectCandidates(){this._garbageCollectionQueued=!1;const{_removedItemCandidates:o}=this,e=Array.from(o);o.clear(),e.forEach(a=>this._garbageCollectIfRemoved(a))}_garbageCollectIfRemoved(o){const{_originalToMapped:e}=this,a=this._getItem(o);a!=null&&a.removed&&(m(a.item),e.delete(o))}}class ${constructor(o){this.item=o,this.removed=!1}markRemoved(){return this.removed=!0,!0}}function m(i){typeof i=="object"&&i&&("destroy"in i&&typeof i.destroy=="function"?i.destroy():v(i))}function Q(i,o,e){const a=new _,r=M(i,s=>y(async t=>{const n=await o(s,t);if(b(t))throw m(n),I();return n}),e),l=()=>null,u=async s=>{const t=await s.promise,n=r.indexOf(s);n<0||a.splice(n,1,t)};a.addMany(r.items.map(l));for(const s of r)p(u(s));const f=r.on("after-splice",({added:s,start:t,deleteCount:n})=>{const d=a.splice(t,n);for(const c of d)m(c);if(s!=null&&s.length){a.addMany(s.map(l),t);for(const c of s)p(u(c))}});return a.addHandles([w(r),f]),a}export{M as c,Q as u};
